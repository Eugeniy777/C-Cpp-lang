Целочисленные типы

Все числа, записанные в коде в виде цифр, по умолчанию имеют тип int, если они достаточно маленькие (см. таблицу ниже). Так, если написать auto x = 1, переменная x автоматически получит тип int. Но это не единственный целочисленный тип данных в С++.
Целочисленные типы содержат положительные и отрицательные целые числа без дробной части. Они отличаются размером, занимаемой памятью и диапазоном значений. Есть знаковые (signed) и беззнаковые (unsigned) целочисленные типы. Знаковые хранят положительные и отрицательные числа и ноль, а беззнаковые — только натуральные числа, включая ноль.

Целочисленные типы С++

Тип		Количество байтов	Количество бит		Количество бит

int		4			32			от -2 147 483 648 до 2 147 483 647
unsigned int	4			32			от 0 до 4 294 967 295
int8_t		1			8			от -128 до 127
uint8_t		1			8			от 0 до 255
int16_t		2			16			от -32 768 до 32 767
uint16_t	2			16			от 0 до 65 535
int32_t		4			32			от -2 147 483 648 до 2 147 483 647
uint32_t	4			32			от 0 до 4 294 967 295
int64_t		8			64			от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
uint64_t	8			64			от 0 до 18 446 744 073 709 551 615

size_t		4 ili 8			32 ili 64		zavisit ot razryadnosti pk

Все типы с суффиксом _t из таблицы доступны при подключении библиотеки cstdint. Гарантируется, что они имеют указанный размер и диапазон значений.
Тип int и его беззнаковый товарищ unsigned int, — стандартные и, как правило, занимают четыре байта. Но это может быть не так на процессорах старой или нестандартной архитектуры.
В старом коде вы можете встретить и другие типы, размер которых чётко не определён. Но для основных архитектур всё-таки можем привести сравнение:

    char — 						int8_t или uint8_t. 
									Да-да, символ в C++ — это просто число с кодом этого символа.
    signed char — 					int8_t
    unsigned char — 					uint8_t
    short int или short — 				int16_t
    unsigned short int или unsigned short — 		uint16_t
    long int или long — 				int32_t
    unsigned long int или unsigned long — 		uint32_t
    long long int или long long — 			int64_t
    unsigned long long int или unsigned long long — 	uint64_t

В новом коде принято использовать int или типы с суффиксом _t из cstdint.
Разберёмся, как выбрать наиболее подходящий для решения задачи целочисленный тип данных.

    Если вам достаточно размера и диапазона значений стандартного типа int — используйте его.
    Если хотите хранить числа порядка триллиона, размер типа int не подойдёт — нужен int64_t.
    Если возникла необходимость экономить память на числах, применяйте типы меньшей размерности, такие как int8_t, int16_t.
    Если вы пишете программу, которая будет запускаться на неизвестной архитектуре, и нуждаетесь в 32-битном типе — выберите int32_t.

Размеры всех типов данных заучивать необязательно: в С++ есть оператор sizeof, который возвращает размер в байтах. Например, мы забыли размер целочисленного типа int16_t. Применим sizeof:

cout << sizeof(int16_t) << endl; 

Программа напомнит, что размер int16_t составляет два байта.
Можно применить sizeof и к выражению. Так мы узнаем, что размер вектора занимает восемь байт:

cout << sizeof(vector<string>{}.size()) << endl; 

Размер пустого вектора строк нулевой. Но зато каков этот ноль! Целых восемь байт.
sizeof удобен, когда вы уже мыслите в битах и на ходу строите логические цепочки: тип занимает восемь байт → это 64 бита → 2^64 больше 10^18 → число из 18 цифр поместится легко. Но можно и явно попросить компилятор вывести минимальное и максимальное значение любого целочисленного типа. Для этого подключим библиотеку limits:

#include <iostream>
#include <limits>
using namespace std;
int main() {
    cout << "sizeof = "s << sizeof(int) << endl;
    cout << "min = "s << numeric_limits<int>::min() << endl;
    cout << "max = "s << numeric_limits<int>::max() << endl;
} 

Запустим код и увидим всё про тип int на нашем процессоре:

sizeof = 4
min = -2147483648
max = 2147483647 

Вы узнали, какие целочисленные типы есть и какой объём памяти они занимают. Научились выяснять по целочисленному типу его размер, минимальное и максимальное значение. В C++ память для целочисленных типов ограничена. Далее разберёмся, что такое переполнение целочисленного типа.