					Инициализация переменных
Вы уже сталкивались с опасностью неинициализированных числовых переменных. Разберём на примере. Объявим переменную x, прибавим к ней восемь и выведем:

#include <iostream>
using namespace std;
int main() {
    // другие операции
    int x;  // не задали начальное значение
    x += 8;
    cout << x << endl;
} 

Если это первые команды в программе, она, скорее всего, выведет 8. Если нет, можем получить произвольное число — например 21889. При этом компилятор видит проблему и даёт предупреждение:

test.cpp: In function ‘int main()’:
test.cpp:14:7: warning: ‘x’ is used uninitialized in this function [-Wuninitialized]
   14 |     x += 8;
      |     ~~^~~~ 

Это наглядная демонстрация одного из базовых принципов C++: не плати за то, что не используешь. Переменная не инициализирована. Автор кода написал: хочу переменную. Переменная появилась, а тратить лишнюю операцию на её зануление нет причин. В мультфильме «Вовка в Тридевятом царстве» двое из ларца получили от Вовки размытые инструкции. И сделали совсем не то, чего он ожидал. С++ тоже требует чётких инструкций: хотите нулевой x — так и напишите.
Инициализируйте все переменные, которые так или иначе относятся к числовым:

    целочисленные — int, size_t, int64_t и пр.;
    вещественные — float, double и пр.;
    char;
    bool;
    enum.

Создание таких локальных переменных — просто резервирование области памяти нужного размера. С точки зрения времени выполнения программы это бесплатно. С более сложными объектами — строками, векторами, словарями — дела обстоят иначе. Создавая их без дополнительной информации, вы гарантированно получите пустой объект.
Та же история с вашими собственными структурами и классами: по умолчанию их поля инициализируются подобно локальным переменным. Как правильно задавать начальные значения полей, вы узнаете в теме о конструкторах.
При этом стандартные классы заботятся о пользователе: созданная по умолчанию пара чисел pair<int, int> x; или вектор, длина которого равна пяти — vector<int> v(5);, — будут содержать нули.
Редкий пример ситуации, когда явная инициализация переменной избыточна:

int document_count;
cin >> document_count; 

Переменная заполнилась конкретным значением сразу после объявления. Но в таком случае мы не можем объявить переменную константной. Отчасти поэтому, а отчасти из-за более сложного считывания в коде поисковой системы мы инициализировали количество документов по-другому:

const int document_count = ReadLineWithNumber(); 

Применим похожий приём, чтобы заполнить переменную разными значениями в зависимости от условия:

int result_temperature;
if (mode == Mode::MIN) {
    result_temperature = min(temperature_today, temperature_yesterday);
} else {
    result_temperature = max(temperature_today, temperature_yesterday);
} 

Такой код опасен: если добавить команды перед if или заменить последний else на else if и добавить в Mode третье значение, в переменной result_temperature может появиться мусор. Исправить получится даже без функции. Применим так называемый тернарный оператор:

const int result_temperature =
    mode == Mode::MIN
    ? min(temperature_today, temperature_yesterday)
    : max(temperature_today, temperature_yesterday); 

Выражение после символа = состоит из трёх частей:

    до ? записано условие, как в if;
    между ? и : записано значение, которое будет результатом выражения, если условие истинно;
    после : записано значение, которое будет результатом выражения, если условие ложно.

Возьмите себе за правило всегда инициализировать переменные и поля числовых типов. И не забывайте включать предупреждения компилятора.